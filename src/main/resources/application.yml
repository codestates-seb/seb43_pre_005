spring:
  datasource:
    url: jdbc:mysql://localhost:3309/stackoverflowDB?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC&useLegacyDatetimeCode=false
    username: ${SPRING_DATASOURCE_USERNAME}
    password: ${SPRING_DATASOURCE_PASSWORD}
    driver-class-name: com.mysql.cj.jdbc.Driver

  jpa:
    hibernate:
      ddl-auto: create
    show-sql: true
    database: mysql
    properties:
      hibernate:
        show_sql: true
        format_sql: true
        dialect: org.hibernate.dialect.MySQL5Dialect
    defer-datasource-initialization: true
    # 이 설정을 추가하면 create 이후의 데이터 sql문이 실행되면서 적용된다..?
    # 초기화 순서~ 문제일수도 ㅇㅇ..
    # hibernate 초기화 / scprit 기반 초기화 두가지
    # 순서에 따라 ~~~

  sql:
    init:
      mode: always
      data-locations: classpath:data-init.sql
      #schema-locations: classpath:schema-init.sql





# none : 자동 DDL 생성 안함.
# create : 하이버네이트 Sessionfactory가 시작될 때 항상 다시 생성, 이미 있다면 지우고 생성.
# create-drop : Sessionfactory가 시작될 때 생성 후 종료할 때 삭제한다.
# update : Sessionfactory가 시작될 때 엔티티 클래스(도메인 클래스)와 DB에 생성된 스키마 구조를 비교해서 DB쪽에 생성이 안된 테이블 또는 칼럼이 있다면 DB 스키마를 변경해서 생성시키지만 기 생성된 스키마 구조를 삭제하지는 않는다.
# validate : Sessionfactory가 시작될 때 엔티티 클래스(도메인 클래스)와 DB에 생성된 스키마 구조를 비교해 같은지 확인만 할 뿐 DB 스키마 구조는 변경하지 않고 만약 다르다면 예외를 발생시킨다.
#(validate -> schema.sql 검사)

# createDatabaseIfNotExist : 데이터베이스가 존재하지 않으면 자동으로 생성
# useUnicode : 유니코드 사용 여부 설정
# characterEncoding : 문자열 인코딩 종류 설정
# characterSetResult : 결과값의 인코딩 종류 설정
# useSSL : SSL 사용 여부 설정

# spring.jpa.properties.hibernate.show_sql : 하이버네이트가 실행한 모든 SQL문을 콘솔로 출력
# spring.jpa.properties.hibernate.format_sql : SQL문을 가독성 있게 표현